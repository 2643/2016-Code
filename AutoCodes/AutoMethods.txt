package org.usfirst.frc.team2643.robot;

	import edu.wpi.first.wpilibj.Encoder;
	import edu.wpi.first.wpilibj.Talon;
	import edu.wpi.first.wpilibj.Timer;

	public class AutoMethods extends Robot{
	//wait .15 of a second and if true then stop all motors
	public static void waitALittle(Boolean stop){
		Timer clock = new Timer();
		clock.reset();
		while(clock.get() < .15){
			if(stop){
			setDrive(0);
				setHook(0);
				intakeMotor.set(0);
			}
		}
	}
	//wait a tiny amount and keep the motors spinning
	public static void waitALittle(double time){
		Timer clock = new Timer();
		clock.reset();
		while(clock.get() < time){
			//Be Patient
		}
	}
	//move forward a certain distance at a certain speed
	public static void moveForward(double distanceTillUp,double speed){
			//encoders resets 
			rightDriveEncoder.reset();
			leftDriveEncoder.reset();
			while(distanceTillUp > leftDriveEncoder.get() || distanceTillUp > rightDriveEncoder.get()){
				//motors are set to a certain 'speed' until both distances are greater than encoder values 
				setDrive(speed);
				
			}
			//stops motors and waits 
			waitALittle(true);
		}
		//cross drawbridge by moving the hooks up, moving forward, lowering the hooks ontop of it
		//pulling it down and then moving forward
		public static void crossDrawbridge() {
			moveHooksUp();
			moveForward(distanceToDefense,.4);
			moveHooksDown(distanceToTopOfDrawbridge);
			pullDownBridge();
			moveForward(distanceToFinishDefense,.4);
			//stop moving and wait a little
			waitALittle(true);
		}
		//code to pull down drawbridge
		//move back while pulling drawbridge down then move forward
		public static void pullDownBridge(){
			//reset drive encoders
			leftDriveEncoder.reset();
			rightDriveEncoder.reset();
			//move back and pull down while both hooks arent at the bottom
			while(leftHookEncoder.get() > 0 && rightHookEncoder.get() > 0){ 
				// update later
				//******DO NOT RUN UNTILL SPEED IS CHANGED******
			
				setDrive(lowerDrawbridgeSpeed);
				
				setHook(-.3);
			}
			//stop pulling down
			setHook(0);
			//move back forward untill the robot is back at its starting position
			while(leftDriveEncoder.get() < 0 && rightDriveEncoder.get() < 0){
			setDrive(0.5);
			
			}
			//stop moving and wait a little
			waitALittle(true);
		}
		//cross the portcullis using by lowering the hooks down, moving forward, raising it then moving past it
		public static void crossPortcullis() {
			moveHooksDown();
			moveForward(distanceToDefense,.4);
			moveHooksUp();
			moveForward(distanceToFinishDefense,.4);
			//stop moving and wait a little
			waitALittle(true);
		}
		//cross the french thing by raising the hooks, moving up to it, pressing the hooks down on the 
		//upward ones and then moving over it
		public static void crossChevalDeFrise() {
			moveHooksUp();
			moveForward(distanceToDefense,.4);
			moveHooksDown();
			moveForward(distanceToFinishDefense,.4);
			//stop moving and wait a little
			waitALittle(true);
		}
		//method to move the hooks down untill either limit switch is hit
		public static void moveHooksDown() {
			while(leftHookEncoder.get()/255 * leftPerimeter >0 && rightHookEncoder.get()/255 * rightPerimeter <0)
			{
				
						setHook(-1);
			}
			setHook(0);
			//stop moving and wait a little
			waitALittle(true);
		}
		//method to move both the hooks down but by a certain amount 
		public static void moveHooksDown(double amount) {
			leftHookEncoder.reset();
			rightHookEncoder.reset();
			while(getDistance(leftHookEncoder.get(),leftDiameter ) > 0 &&
					getDistance(rightHookEncoder.get(),rightDiameter) > 0){
			setHook(-1);
			}
			setHook(0);
		}
		//move the hooks up until either limit switch is hit
		public static void moveHooksUp() {
			while((getDistance(rightHookEncoder.get(),rightDiameter) < 0 &&
					getDistance(leftHookEncoder.get(),leftDiameter) > 0)){
				//update later 
			setHook(1);
			}
						setHook(0);
		}
		//method to cross the sallyport
		public static void crossSallyPort() {
			//pull it open while turning back to let people in
		}
		//cross the moat by moving straight over it
		public static void crossMoat(double distanceOverObject) {
			moveForward(distanceOverObject,.5);
		}
		//cross the rough terrain by moving forward
		public static void crossRoughTerrain(double distanceOverObject) {
			moveForward(distanceOverObject,.7);
		}
		//cross the ramparts by moving forward
		public static void crossRamparts(double distanceOverObject) {
			moveForward(distanceOverObject,.6);
		}
		//cross the rock wall by moving forward at a much slower speed
		public static void crossRockWall(double distanceOverObject) {
			moveForward(distanceOverObject,.3);
		}
		//method to turn either left or right, move forward 
		//in terms of length of defenses then face forward again
		public static void turnMove(int shiftPosition) {
			//if the you're going to go right
			if(shiftPosition > 0){
				turnRight();
				moveForward(distanceBetweenDefenses*shiftPosition,1);
				turnLeft();
				//if you're going to go left
			}else if(shiftPosition < 0){
				turnLeft();
				moveForward((-1)*distanceBetweenDefenses*shiftPosition,1);
				turnRight();
			}
		}
		//method to turn right 90 degrees
		public static void turnRight() {
			rightDriveEncoder.reset();
			leftDriveEncoder.reset();
			//start spinning right untill both encoders are met
			while(turn90Amount > leftDriveEncoder.get() || (-1)*turn90Amount < rightDriveEncoder.get()){
				frontLeftMotor.set(1);
				frontRightMotor.set(-1);
				backLeftMotor.set(1);
				backRightMotor.set(-1);
			}
			//stop spinning
			setDrive(0);
		}
		//turn left by 90 degrees
		public static void turnLeft() {
			rightDriveEncoder.reset();
			leftDriveEncoder.reset();
			//start spinning left untill both encoders are met
			while((-1)*turn90Amount < leftDriveEncoder.get() || turn90Amount > rightDriveEncoder.get()){
				frontLeftMotor.set(-1);
				frontRightMotor.set(1);
				backLeftMotor.set(-1);
				backRightMotor.set(1);
			}
			//stop spinning
			setDrive(0);
		}
		//turn left by a certain amount
		public static void turnLeft(double amount) {
			rightDriveEncoder.reset();
			leftDriveEncoder.reset();
			//start spinning untill both encoders are above the desired amount
			while((-1)*amount < leftDriveEncoder.get() || amount > rightDriveEncoder.get()){
				frontLeftMotor.set(-1);
				frontRightMotor.set(1);
				backLeftMotor.set(-1);
				backRightMotor.set(1);
			}
			//stop spinning
			setDrive(0);
		}
		//turn right by a certain amount
		public static void turnRight(double amount) {
			rightDriveEncoder.reset();
			leftDriveEncoder.reset();
			//spin untill both amounts are met
			while(amount > leftDriveEncoder.get() || (-1)*amount < rightDriveEncoder.get()){
				frontLeftMotor.set(1);
				frontRightMotor.set(-1);
				backLeftMotor.set(1);
				backRightMotor.set(-1);
			}
			//stop spinning
			//stop moving and wait a little
			waitALittle(true);
		}
		//move and turn either right or left and then face forward
		//then move forward to the correct shooting position
		//turn to face the goal
		public static void goToShootingPosition() {
			//take the goal and multiply it by 2 and subtract 1 to yield either 1 3 or 5
			//which is the desired horizontal position to be after the movement
			//subtract that by the current positon to yeild the int of how much you need to move
			//current position is equal to the starting position plus the shifts it has made
			turnMove((goal*2-1)-(startingPosition+shiftStartingPosition));
			//if the goal is one of the side ones
			if(goal != 2){
				//move forward by a large amount
				moveForward(distanceToFarGoal,.5);
				if(goal == 1){
					//turn right when you're at the left goal to face right
					turnRight(amountToFaceSideGoalsInAuto);
				}else if(goal == 3){
					//turn left when you're at the right goal to face left
					turnLeft(amountToFaceSideGoalsInAuto);
				}
			}else{
				//move forward by a small amount
				moveForward(distanceToMidGoal,.5);
				//stop moving and wait a little
				waitALittle(true);
			}
		}
		//have the motors start spinning to find a desired speed
		public static void startSpinning() {
			shooterMotor.set(desiredSpeed);
		}
		//drive smoothly at a desired speed
		public static void setDrive(double speed){
			while(driveSpeed != speed){
				frontLeftMotor.set(driveSpeed);
				frontRightMotor.set(driveSpeed);
				backLeftMotor.set(driveSpeed);
				backRightMotor.set(driveSpeed);
				if(driveSpeed-speed > .1){
					driveSpeed -= .1;
				}else if(driveSpeed-speed < .1){
					driveSpeed += .1;
				}else{
					driveSpeed = speed;
				}
				waitALittle(.05);
			}
		}
		//hook things smoothly at a desired speed
		public static void setHook(double speed){
			while(driveSpeed != speed){
				setHook(hookSpeed);
				if(hookSpeed-speed > .1){
					hookSpeed -= .1;
				}else if(hookSpeed-speed < .1){
					hookSpeed += .1;
				}else{
					hookSpeed = speed;
				}
				waitALittle(.05);
			}
		}
		
		//shoot the ball
		public static void shoot() {
			intakeMotor.set(.5);
			waitALittle(.7);
			intakeMotor.set(0);
		}
		
		public static double getDistance(double encoderTicks, double diameter ) {
			double revolution = encoderTicks/255;
			double perimeter = Math.PI*diameter;
			double distance = revolution*perimeter;
			
			
			return distance;
			
		}
		
			//make the already spinning motors spin the thingy to move the ball
		}
		
	
//Accelerate code --> replace all of the set motors with setDrive and setHook
//Shooting code 
//Remember to change the Encoder to inches
	
	